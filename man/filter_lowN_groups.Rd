% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_lowN_groups.R
\name{filter_lowN_groups}
\alias{filter_lowN_groups}
\title{Filter Low-N Groups from a Summary Data Frame}
\usage{
filter_lowN_groups(
  summary_df,
  lowN_groups_df,
  acad_group_var = NULL,
  demo_group_var = NULL,
  time_group_var = NULL
)
}
\arguments{
\item{summary_df}{A data frame of summarized counts, typically the output of
\code{summarize_response_counts}.}

\item{lowN_groups_df}{A data frame identifying groups with low respondent
counts, typically the output of \code{identify_lowN_groups}.}

\item{acad_group_var}{The original academic grouping variable name used to
create the summaries. Defaults to \code{NULL}.}

\item{demo_group_var}{The original demographic grouping variable name used to
create the summaries. Defaults to \code{NULL}.}

\item{time_group_var}{The original time grouping variable name used to
create the summaries. Defaults to \code{NULL}.}
}
\value{
A data frame, identical in structure to \code{summary_df}, but with rows
corresponding to the groups in \code{lowN_groups_df} removed.
}
\description{
This function takes a summary data frame (produced by
\code{summarize_response_counts}) and a data frame of low-N groups (produced
by \code{identify_lowN_groups}) and filters out the rows from the summary that
correspond to the low-N groups. It maps the original grouping variable names
to the standardized \code{..._group_value} columns in the summary data frame.
}
\examples{
# Attach required libraries
library(dplyr)
library(purrr)
library(rlang)

# Create the same sample data frame as before
df_counts <- data.frame(
  rowid = 1:10,
  ITEM_PARENT_ID = c("Q1", "Q1", "Q1", "Q2", "Q2", "Q1", "Q1", "Q2", "Q2", "Q1"),
  ITEM_NAME = c("Q1_A", "Q1_B", "Q1_A", "Q2_X", "Q2_Y", "Q1_B", "Q1_A", "Q2_X", "Q2_Y", "Q1_A"),
  ITEM_TYPE = c("Single Select", "Single Select", "Single Select", "Multi Select", "Multi Select",
                "Single Select", "Single Select", "Multi Select", "Multi Select", "Single Select"),
  response = c("Yes", "No", "Yes", "Option1", "Option2", "No", "Yes", "Option1", "Option3", "Yes"),
  Department = c("Math", "Physics", "Math", "Physics", "Math", "Math", "Physics", "Physics", "Math", "Math"),
  Year = c(2023, 2023, 2024, 2024, 2023, 2023, 2024, 2024, 2023, 2024)
)

# --- Workflow Example ---

# 1. Define grouping variables and threshold
my_group_vars <- c("Department", "Year")
my_threshold <- 3

# 2. Create the full summary
full_summary <- summarize_response_counts(df_counts,
                                          acad_group_var = "Department",
                                          time_group_var = "Year")
cat("--- Full Summary (before filtering) ---\n")
print(full_summary)

# 3. Identify the low-N groups
low_n_groups <- identify_lowN_groups(df_counts,
                                     group_cols = my_group_vars,
                                     threshold = my_threshold)
cat("\n--- Groups Identified as Low-N (n < 3) ---\n")
print(low_n_groups)
# Note: The (Physics, 2023), (Math, 2024), and (Physics, 2024) groups
# have respondent counts of 1, 2, and 2 respectively.

# 4. Filter the summary to exclude the low-N groups
filtered_summary <- filter_lowN_groups(full_summary, low_n_groups,
                                       acad_group_var = "Department",
                                       time_group_var = "Year")
cat("\n--- Filtered Summary (after excluding low-N groups) ---\n")
print(filtered_summary)
# The result only contains data for the (Math, 2023) group.

}
\seealso{
Other data analysis functions: 
\code{\link{summarize_response_counts}()}
}
\concept{data analysis functions}
